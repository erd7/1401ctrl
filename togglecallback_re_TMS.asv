%On event calls method for 1401 trigger routine via digital out for TMS sequence
classdef togglecallback_re_TMS < handle
   properties (SetAccess = public, GetAccess = public)
      ListeningTo
      SignalObj
      InputObj
      Prefs
      Parent
      DacScale = 2^16/10; %implement as device property in separate data holding class/struct; Voltage scaling by DAC units: voltage resolution is given by 16bit for a 10V range; thus 1V equals to 6553.6 DAC units/ minimum step width (resolution) is 1,53mV (1DAC unit)
      TrigSq
   end
   methods
      %Constructor:
      function obj = togglecallback_re_TMS(h,srcobj,srcobj2,srcobj3)
         obj.Parent = h.main;
         obj.ListeningTo = srcobj;
         obj.SignalObj = srcobj2;
         obj.InputObj = srcobj3;
         obj.Prefs = getappdata(obj.Parent,'preferences');
         
         addlistener(obj.ListeningTo,'ToggleOn',@(src,evt)StimCtrl(obj,src,evt));
        
         %Following code is to be implemented at a more appropriate point:
         MATCED32('cedSendString','CLEAR');
         %MATCED32('cedLdX',obj.Prefs.langpath,'DIGTIM'); %In Optionen von user entry abhängig machen? //Geschieht bereits in Noise_Callback
         
         obj.GenTrigSq(60,0);
      end
      function GenTrigSq(obj,dur,isi) %//Implementiere ISI-Eingabe; //In SIGNALOBJ. implementieren! --> bisher kein update zur laufzeit möglich!
         %INTERVALLMAXIMUM DARF NICHT == HÄLFTE D. STIMSUBINTERVALS BETRAGEN!
         dur = 60;
         frqsubdiv = 1000;
         time = [1:dur*frqsubdiv*10]*0; %//second factor is frq subdiv, third is measured in seconds (10 seconds for each step now);
         t1 = 3*frqsubdiv;

         for i=1:(dur)
            time(t1) = 1;
   
            t2 = t1+3*frqsubdiv+randi(3*frqsubdiv);
      
            while (i*10*frqsubdiv - t2) > 5*frqsubdiv
               t2 = t1+3*frqsubdiv+randi(3*frqsubdiv);
            end
   
            t3 = t2+3*frqsubdiv+randi(3*frqsubdiv);
   
            while t3 < (i*10*frqsubdiv)
               t3 = t2+3*frqsubdiv+randi(3*frqsubdiv);
            end
   
            time(t2) = 1;
            t1 = t3;
         end
         obj.TrigSq = find(time);
         clear time;
      end      
      function StimCtrl(obj,src,evt)
         obj.Prefs = getappdata(obj.Parent,'preferences');
         runs = length(obj.TrigSq);
         trigint = obj.TrigSq(1);    
                  
         MATCED32('cedSendString',['DIGTIM,SI,',num2s,',',num2str(2*16*runs),';']);
         MATCED32('cedSendString',['DIGTIM,A,1,1,',num2str(trigint),';']);
         MATCED32('cedSendString','DIGTIM,A,1,0,2;');
         
         for i=1:(runs-1)
            trigint = obj.TrigSq(i+1)-obj.TrigSq(i)-2;
            MATCED32('cedSendString',['DIGTIM,A,1,1,',num2str(trigint),';']);
            MATCED32('cedSendString','DIGTIM,A,1,0,2;');
         end
         MATCED32('cedSendString','DIGTIM,OD;');
         MATCED32('cedSendString','DIGTIM,C,10,100;'); %//implement clock rate to depend on frqsubdiv; or vice versa (everything dependent on dig sample rate!
      end
   end
end