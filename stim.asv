classdef stim < handle
   properties (SetAccess = public, GetAccess = public)
      ListeningTo
   end
   methods
      %Constructor:
      function obj = stim(src)
         obj.ListeningTo = src;
         addlistener(obj.ListeningTo,'ToggleOn',@(src,evt)respond(obj,src,evt,obj.ListeningTo));
       
      end
   end
   

function r = stim(amp,frq)
%power1401 stim routine
%next to implement: REALTIME SAMPLE OUTPUT AND INPUT!

dacScale = 32768/5; %Voltage scaling by DAC-units; CHECK "voltage resolution": note 16bit for -5V to +5V (--> 2^16/10 = 6553,6 as step width of 1V)
z = 0; %intermed. var for signal array creation
datalength = 40000;

scaleAmp = dacScale*amp;
dacOut = gen_signal(scaleAmp,frq); %output signal setup (see gen_signal()); --> dacOut will be array of size = z with all operations defined done to it --> digits of the sinus-curve! (VERIF.)
   %--> every successive voltage value is send to power1401! check: max. ram load!
   %--> to generate complex signals change digits of dacOut- Array manually!
   
MATCED32('cedTo1401',datalength,0,dacOut);
sz = int2str(2*datalength); %sz: number of BYTES to be transferred; CHECK MEMDAC PARAMS UP FROM HERE!

%chk = -1;
%while chk ~=0
%   MATCED32('cedSendString','MEMDAC,?;');
%   chk = eval(MATCED32('cedGetString'));
%   %chk = MATCED32('cedGetString'); %does not work!
%   % pause(0.1);  % this is an alternative to drawnow
%   r = chk;
%   drawnow; % flushes the event queue
%end

chk = -1;
MATCED32('cedSendString','MEMDAC,?;');
chk = eval(MATCED32('cedGetString'));
drawnow;

if chk==1 || chk==0
   %OUTPUT: just use DAC0; immediate signal, no trigger! use HT for trigger, check exsample code; disable interrupt for output loop?
   MATCED32('cedSendString',['MEMDAC,I,2,0,' sz ',0,1,H,10,10;']); %analog waveform output from RAM-Data (--> MEMDAC): kind: I (interrupt driven), byte: 2 (thus 16bit data), st: 0 (start at user RAM address 0); sz (size of transferred data, look above), chan: 0 (defines output channel: DAC-output 0), rpts: 1 (number of repeats), clock: H (high-speed clock: 4MHz (native sample rate; SEE FURTHER)), pre*cnt: 10*10 = 100: downsampling the selected clock by divisor of 100! --> sample rate of 40kHz, as implemented above! --> see manual: "clock set up"
   %--> immediate reading from memory --> immediate output; also see trigger option via event port E3; s. MEMDAC-Doku --> sweeps? array position?
else
   r = chk;
end

%read immediately!
%MATCED32('cedSendString',['ADCMEM,I,2,1800,' sz ',0,1,H,10,10;']); %analog waveform output from RAM-Data (--> MEMDAC): kind: I (interrupt driven), byte: 2 (thus 16bit data), st: 0 (start at user RAM address 0); sz (size of transferred data, look above), chan: 0 (defines output channel: DAC-output 0), rpts: 1 (number of repeats), clock: H (high-speed clock: 4MHz (native sample rate; SEE FURTHER)), pre*cnt: 10*10 = 100: downsampling the selected clock by divisor of 100! --> sample rate of 40kHz, as implemented above! --> see manual: "clock set up" 

%fprintf('STIM DONE');

end